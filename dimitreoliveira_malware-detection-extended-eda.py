import gc

import dask

import dask.dataframe as dd

import warnings

import cufflinks

import numpy as np

import pandas as pd

import seaborn as sns

import matplotlib.pyplot as plt

import plotly.plotly as py

import plotly.graph_objs as go

from plotly.offline import init_notebook_mode, iplot



gc.enable()


sns.set(style="whitegrid")

warnings.filterwarnings("ignore")

cufflinks.go_offline(connected=True)

init_notebook_mode(connected=True)
dtypes = {

        'MachineIdentifier':                                    'category',

        'ProductName':                                          'category',

        'EngineVersion':                                        'category',

        'AvSigVersion':                                         'category',

        'IsBeta':                                               'int8',

        'RtpStateBitfield':                                     'float16',

        'IsSxsPassiveMode':                                     'int8',

        'AVProductsInstalled':                                  'float16',

        'AVProductsEnabled':                                    'float16',

        'HasTpm':                                               'int8',

        'CountryIdentifier':                                    'int16',

        'OrganizationIdentifier':                               'float16',

        'GeoNameIdentifier':                                    'float16',

        'LocaleEnglishNameIdentifier':                          'int8',

        'Platform':                                             'category',

        'Processor':                                            'category',

        'OsVer':                                                'category',

        'OsSuite':                                              'int16',

        'OsPlatformSubRelease':                                 'category',

        'SkuEdition':                                           'category',

        'IsProtected':                                          'float16',

        'AutoSampleOptIn':                                      'int8',

        'SMode':                                                'float16',

        'IeVerIdentifier':                                      'float16',

        'SmartScreen':                                          'category',

        'Firewall':                                             'float16',

        'UacLuaenable':                                         'float32',

        'Census_MDC2FormFactor':                                'category',

        'Census_DeviceFamily':                                  'category',

        'Census_ProcessorCoreCount':                            'float16',

        'Census_ProcessorManufacturerIdentifier':               'float16',

        'Census_PrimaryDiskTypeName':                           'category',

        'Census_SystemVolumeTotalCapacity':                     'float32',

        'Census_HasOpticalDiskDrive':                           'int8',

        'Census_TotalPhysicalRAM':                              'float32',

        'Census_ChassisTypeName':                               'category',

        'Census_InternalPrimaryDiagonalDisplaySizeInInches':    'float16',

        'Census_InternalPrimaryDisplayResolutionVertical':      'float16',

        'Census_PowerPlatformRoleName':                         'category',

        'Census_OSVersion':                                     'category',

        'Census_OSArchitecture':                                'category',

        'Census_OSBranch':                                      'category',

        'Census_OSBuildRevision':                               'int32',

        'Census_OSEdition':                                     'category',

        'Census_OSSkuName':                                     'category',

        'Census_OSInstallTypeName':                             'category',

        'Census_OSInstallLanguageIdentifier':                   'float16',

        'Census_OSUILocaleIdentifier':                          'int16',

        'Census_OSWUAutoUpdateOptionsName':                     'category',

        'Census_IsPortableOperatingSystem':                     'int8',

        'Census_GenuineStateName':                              'category',

        'Census_ActivationChannel':                             'category',

        'Census_IsFlightsDisabled':                             'float16',

        'Census_FlightRing':                                    'category',

        'Census_IsSecureBootEnabled':                           'int8',

        'Census_IsVirtualDevice':                               'float16',

        'Census_IsTouchEnabled':                                'int8',

        'Census_IsPenCapable':                                  'int8',

        'Census_IsAlwaysOnAlwaysConnectedCapable':              'float16',

        'Wdft_IsGamer':                                         'float16',

        'Wdft_RegionIdentifier':                                'float16',

        'HasDetections':                                        'int8'

        }



use_columns = ['MachineIdentifier', 'ProductName', 'EngineVersion', 'AvSigVersion', 'IsBeta', 'RtpStateBitfield', 'IsSxsPassiveMode', 'AVProductsInstalled', 

               'AVProductsEnabled', 'HasTpm', 'CountryIdentifier', 'OrganizationIdentifier', 'GeoNameIdentifier', 'LocaleEnglishNameIdentifier', 'Platform', 

               'Processor', 'OsVer', 'OsSuite', 'OsPlatformSubRelease', 'SkuEdition', 'IsProtected', 'AutoSampleOptIn', 'SMode', 'IeVerIdentifier', 

               'SmartScreen', 'Firewall', 'UacLuaenable', 'Census_MDC2FormFactor', 'Census_DeviceFamily', 'Census_ProcessorCoreCount', 'Census_ProcessorManufacturerIdentifier', 

               'Census_PrimaryDiskTypeName', 'Census_SystemVolumeTotalCapacity', 'Census_HasOpticalDiskDrive', 'Census_TotalPhysicalRAM', 'Census_ChassisTypeName', 

               'Census_InternalPrimaryDiagonalDisplaySizeInInches', 'Census_InternalPrimaryDisplayResolutionVertical', 'Census_PowerPlatformRoleName', 

               'Census_OSVersion', 'Census_OSArchitecture', 'Census_OSBranch', 'Census_OSBuildRevision', 'Census_OSEdition', 'Census_OSSkuName', 'Census_OSInstallTypeName', 

               'Census_OSInstallLanguageIdentifier', 'Census_OSUILocaleIdentifier', 'Census_OSWUAutoUpdateOptionsName', 'Census_IsPortableOperatingSystem', 

               'Census_GenuineStateName', 'Census_ActivationChannel', 'Census_IsFlightsDisabled', 'Census_FlightRing', 'Census_IsSecureBootEnabled', 

               'Census_IsVirtualDevice', 'Census_IsTouchEnabled', 'Census_IsPenCapable', 'Census_IsAlwaysOnAlwaysConnectedCapable', 'Wdft_IsGamer', 

               'Wdft_RegionIdentifier']



numerics = ['int8', 'int16', 'int32', 'int64', 'float16', 'float32', 'float64']
train = dd.read_csv('../input/microsoft-malware-prediction/train.csv', dtype=dtypes, usecols=(use_columns + ['HasDetections'])).compute()

test = dd.read_csv('../input/microsoft-malware-prediction/test.csv', dtype=dtypes, usecols=use_columns).compute()
# Create statistics for train and test sets.

def dataset_stats(dataset):

    stats = []

    for col in dataset.columns:

        if col != 'HasDetections':

            n_unique = dataset[col].nunique()

            col_type = dataset[col].dtype

            if col_type in numerics:

                col_type = 'Numerical'

            if col_type == 'category':

                col_type = 'Categorical'

            if n_unique == 2:

                col_type = 'Binary'

            if n_unique == 1:

                col_type = 'Constant'

            stats.append((col, n_unique, col_type))



    return pd.DataFrame(stats, columns=['Feature', 'Unique values', 'Type']).sort_values('Unique values', ascending=False)



train_stats = dataset_stats(train)

test_stats = dataset_stats(test)
# Join statistics from train and test into a single dataframe.

join_stats = train_stats.copy()

join_stats.columns = ['Feature', 'Train Unique values', 'Train Type']

join_stats['Test Unique values'] = 0

join_stats['Test Type'] = '???'



for index, row in join_stats.iterrows():

    for test_index, test_row in test_stats.iterrows():

        if row['Feature'] == test_row['Feature']:

            join_stats.loc[index, 'Test Unique values'] = test_row['Unique values']

            join_stats.loc[index, 'Test Type'] = test_row['Type']



join_stats['% changed'] = (1 - (join_stats['Test Unique values'] / join_stats['Train Unique values'])) * 100

join_stats = join_stats[['Feature', 'Train Unique values', 'Test Unique values', '% changed', 'Train Type', 'Test Type']]

join_stats
print('------Train------')

print(join_stats['Train Type'].value_counts())

print('------Test------')

print(join_stats['Test Type'].value_counts())
cat_increase = join_stats[join_stats['% changed'] > 10]

cat_decrease = join_stats[join_stats['% changed'] < -10]

cat_change = cat_increase.append(cat_decrease).sort_values('% changed', ascending=False)

display(cat_change)



f, ax = plt.subplots(figsize=(12, 6))

ax = sns.barplot(x=cat_change['Feature'].values, y=cat_change['% changed'].values, palette="rocket")

ax.set_ylabel("Percentage")

plt.xticks(rotation=80)

plt.show()
del test_stats, join_stats, cat_increase, cat_decrease, test

gc.collect()
binary_features = list(train_stats[train_stats['Type'] == 'Binary']['Feature'])

for feature in binary_features:

    if feature != 'HasDetections':

        sns.catplot(x=feature, hue='HasDetections', data=train, kind='count', height=4)
numeric_features = ['Census_ProcessorCoreCount',

                    'Census_SystemVolumeTotalCapacity',

                    'Census_TotalPhysicalRAM',

                    'Census_InternalPrimaryDiagonalDisplaySizeInInches',

                    'Census_InternalPrimaryDisplayResolutionVertical',

                    'AVProductsInstalled',

                    'AVProductsEnabled',

                    'RtpStateBitfield']



for feature in numeric_features:

    trimmed_df = train[train[feature] < train[feature].quantile(0.95)]



    f, (ax1, ax2) = plt.subplots(1, 2, figsize=(24, 4))

    sns.boxplot(y="HasDetections", x=feature, data=train, orient='h', ax=ax1).set_title("Complete set", fontsize=18)

    if len(trimmed_df) > 0:

        sns.boxplot(y="HasDetections", x=feature, data=trimmed_df, orient='h', ax=ax2).set_title("Values between 5 and 95 percentiles", fontsize=18)

    plt.show()
# Break plots in parts

fifth_cols = len(numeric_features) // 4

cols1 = list(numeric_features[:fifth_cols]) + ['HasDetections']

cols2 = list(numeric_features[fifth_cols:fifth_cols*2]) + ['HasDetections']

cols3 = list(numeric_features[fifth_cols*2:fifth_cols*3]) + ['HasDetections']

cols4 = list(numeric_features[fifth_cols*3:]) + ['HasDetections']



sns.set(style="ticks")

sns.set(font_scale=2)

sns.pairplot(train[cols1], hue="HasDetections", height=7)

plt.show()
sns.pairplot(train[cols2], hue="HasDetections", height=7)

plt.show()
sns.pairplot(train[cols3], hue="HasDetections", height=7)

plt.show()
sns.pairplot(train[cols4], hue="HasDetections", height=7)

plt.show()
corrs = train[numeric_features].corr()

sns.set(font_scale=1)

f, ax = plt.subplots(figsize=(10, 10))

sns.heatmap(corrs, annot=True, linewidths=.5, fmt=".2f", ax=ax)

plt.show()
test = dd.read_csv('../input/microsoft-malware-prediction/test.csv', dtype=dtypes, usecols=use_columns).compute()



# IMPORT TIMESTAMP DICTIONARY

datedict = np.load('../input/malware-timestamps/AvSigVersionTimestamps.npy')

datedict = datedict[()]

# ADD TIMESTAMPS

train['Date'] = train['AvSigVersion'].map(datedict)

test['Date'] = test['AvSigVersion'].map(datedict)



train.drop('AvSigVersion', axis=1, inplace=True)

test.drop('AvSigVersion', axis=1, inplace=True)



print('Train set shape', train.shape)

print('Test set shape', test.shape)

train.head()
print('Train set min date', train['Date'].min().date())

print('Train set max date', train['Date'].max().date())

print('Test set min date ', test['Date'].min().date())

print('Test set max date ', test['Date'].max().date())
train['Date'] = pd.to_datetime(train['Date'],).dt.strftime('%Y-%m')

test['Date'] = pd.to_datetime(test['Date'],).dt.strftime('%Y-%m')



df_train = train.groupby('Date', as_index=False)['MachineIdentifier'].count()

df_test = test.groupby('Date', as_index=False)['MachineIdentifier'].count()

train_test = pd.merge(df_train, df_test, how='outer', on='Date', suffixes=('_train', '_test')).set_index('Date')

train_test.fillna(0, inplace=True)



train_test.iplot(kind='bar', xTitle='Date', yTitle='Count', title='Monthly machine count')
df_train2 = train.groupby('Date', as_index=False)['HasDetections'].sum().set_index('Date')

df_train2.iplot(kind='bar', xTitle='Date', yTitle='Count', title='Monthly malware detection')
n_train_unique_ids = train['MachineIdentifier'].nunique()

n_test_unique_ids = test['MachineIdentifier'].nunique()

train_unique_ids = set(train['MachineIdentifier'].unique())

test_unique_ids = set(test['MachineIdentifier'].unique())

train_only_ids = list(train_unique_ids - test_unique_ids)

test_only_ids = list(test_unique_ids - train_unique_ids)

both_set_ids = list(train_unique_ids & test_unique_ids)

ids_df = pd.DataFrame([(len(train_only_ids), 'Train only ids'), (len(test_only_ids), 'Test only ids'), (len(both_set_ids), 'Both sets ids')], columns=['values', 'labels'])



print('IDs only in train set:', len(train_only_ids))

print('IDs only in test set:', len(test_only_ids))

print('IDs in both sets:', len(both_set_ids))

ids_df.iplot(kind='pie',labels='labels',values='values')